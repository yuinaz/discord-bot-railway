<<<<<<< HEAD
from __future__ import annotations

import asyncio
import json
import logging
import os
import re
from collections import deque
from typing import Dict, Any, Deque, Set

import discord
from discord.ext import commands

LOGGER = logging.getLogger(__name__)

# --- Inline XP Rules (no ENV) ---
TK_TOTAL = 2000
L1_CUTOFF = 1000
L2_CUTOFF = 2000

# Channel guard (no XP here)
CHANNEL_BLOCKLIST = {
    1400375184048787566,
}

DATA_DIR = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(__file__)))), "data")
STORE_PATH = os.path.join(DATA_DIR, "xp_store.json")
AWARDED_IDS_PATH = os.path.join(DATA_DIR, "xp_awarded_ids.json")

# Avoid runaway memory â€” persist awarded message ids with a ring buffer behavior
MAX_AWARDED_IDS = 50000

def _ensure_data_files():
    os.makedirs(DATA_DIR, exist_ok=True)
    if not os.path.exists(STORE_PATH):
        with open(STORE_PATH, "w", encoding="utf-8") as f:
            json.dump({}, f)
    if not os.path.exists(AWARDED_IDS_PATH):
        with open(AWARDED_IDS_PATH, "w", encoding="utf-8") as f:
            json.dump({"ids": []}, f)

def _load_store() -> Dict[str, Any]:
    _ensure_data_files()
    try:
        with open(STORE_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}

def _save_store(store: Dict[str, Any]):
    _ensure_data_files()
    tmp = STORE_PATH + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(store, f, ensure_ascii=False, indent=2)
    os.replace(tmp, STORE_PATH)

def _load_awarded_ids() -> Deque[int]:
    _ensure_data_files()
    try:
        with open(AWARDED_IDS_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)
            ids = data.get("ids", [])
            dq: Deque[int] = deque(maxlen=MAX_AWARDED_IDS)
            for v in ids[-MAX_AWARDED_IDS:]:
                dq.append(v)
            return dq
    except Exception:
        return deque(maxlen=MAX_AWARDED_IDS)

def _save_awarded_ids(dq: Deque[int]):
    _ensure_data_files()
    tmp = AWARDED_IDS_PATH + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump({"ids": list(dq)}, f, ensure_ascii=False)
    os.replace(tmp, AWARDED_IDS_PATH)

def compute_level(total_xp: int) -> str:
    if total_xp < L1_CUTOFF:
        return "TK-L1"
    if total_xp < L2_CUTOFF:
        return "TK-L2"
    # Lewat TK -> anggap masuk SD-L1 untuk kompatibilitas ke depan
    return "SD-L1"

LOG_PATTERNS = [
    re.compile(r"^(INFO|WARNING|ERROR)\:"),        # log-style spam
    re.compile(r"loaded satpambot", re.IGNORECASE),
    re.compile(r"smoke_cogs\.py|smoke_lint_thread_guard\.py", re.IGNORECASE),
]

def _is_spam_like(content: str) -> bool:
    if not content:
        return False
    if len(content) > 2000 or content.count("\n") > 30:
        return True
    return any(p.search(content) for p in LOG_PATTERNS)

class LearningPassiveObserver(commands.Cog):
    """Passive XP earner (no ENV). Stores to data/xp_store.json and dedupes by message id.
    """

    def __init__(self, bot: commands.Bot):
        self.bot = bot
        self.store: Dict[str, Any] = _load_store()
        self.awarded_ids: Deque[int] = _load_awarded_ids()
        # author cooldown: avoid +1 on rapid spam
        self.author_last_ts: Dict[int, float] = {}
        self.cooldown_sec = 5.0  # tweakable here (no ENV)

    def _user_key(self, guild_id: int, user_id: int) -> str:
        return f"{guild_id}:{user_id}"

    def _add_xp(self, guild_id: int, user_id: int, msg_id: int) -> None:
        key = self._user_key(guild_id, user_id)
        rec = self.store.get(key, {"xp": 0})
        rec["xp"] = int(rec.get("xp", 0)) + 1
        self.store[key] = rec
        self.awarded_ids.append(int(msg_id))
        _save_store(self.store)
        _save_awarded_ids(self.awarded_ids)
        level = compute_level(rec["xp"])
        LOGGER.info("[passive-learning] +1 XP -> total=%s level=%s", rec["xp"], level)

    @commands.Cog.listener()
    async def on_message(self, message: discord.Message):
        # Skip bots / DMs / no content
        if message.author.bot or not message.guild:
            return
        if message.channel.id in CHANNEL_BLOCKLIST:
            return
        if _is_spam_like(message.content or ""):
            return

        # Dedup by message id if we've already awarded
        mid = int(message.id)
        if mid in self.awarded_ids:
            return

        # Simple per-author cooldown to reduce +1 spam storms
        ts = message.created_at.timestamp() if message.created_at else 0.0
        last = self.author_last_ts.get(message.author.id, 0.0)
        if ts and last and (ts - last) < self.cooldown_sec:
            return
        self.author_last_ts[message.author.id] = ts or last

        # Award
        try:
            self._add_xp(message.guild.id, message.author.id, mid)
        except Exception as e:
            LOGGER.exception("XP award failed: %s", e)

async def setup(bot: commands.Bot):
    await bot.add_cog(LearningPassiveObserver(bot))
=======
# learning_passive_observer.py
from discord.ext import commands, tasks
import discord, logging, json, time
from pathlib import Path
log = logging.getLogger(__name__)
DATA_FILE = Path("data/neuro-lite/learn_progress_junior.json")
BAN_LOG_FILE = Path("data/neuro-lite/ban_events.jsonl")
BLOCK_CHANNEL_IDS = {763793237394718744}
MSG_MIN_CHARS = 10
POINTS_PER_MSG = 1
POINTS_PER_100_CHARS = 1
HOUR_TARGET_POINTS = 10_000  # 1 point = 0.01%%
BOT_BAN_POINTS = 100
MOD_ADMIN_BAN_POINTS = 25
LEVEL_THRESHOLDS = [(0,"TK"),(1_000,"SD"),(5_000,"SMP"),(15_000,"SMA"),(30_000,"Diploma"),(60_000,"Sarjana"),(120_000,"Master"),(240_000,"Gubernur")]
def _level_from_xp(xp: int):
    name = LEVEL_THRESHOLDS[0][1]
    for t, n in LEVEL_THRESHOLDS:
        if xp >= t: name = n
        else: break
    return name
def _safe_load(p: Path):
    try:
        if p.exists():
            with p.open("r", encoding="utf-8") as f: return json.load(f)
    except Exception as e: log.warning("[passive-learning] load fail: %s", e)
    return {"xp_total":0,"hour_progress_pct":0,"hour_points":0,"hour_start":int(time.time()),"level":"TK"}
def _safe_dump(p: Path, data: dict):
    try:
        p.parent.mkdir(parents=True, exist_ok=True)
        tmp = p.with_suffix(".tmp")
        with tmp.open("w", encoding="utf-8") as f: json.dump(data, f, ensure_ascii=False, indent=2)
        tmp.replace(p)
    except Exception as e: log.warning("[passive-learning] save fail: %s", e)
def _append_jsonl(p: Path, obj: dict):
    try:
        p.parent.mkdir(parents=True, exist_ok=True)
        with p.open("a", encoding="utf-8") as f: f.write(json.dumps(obj, ensure_ascii=False) + "\n")
    except Exception as e: log.warning("[passive-learning] append jsonl fail: %s", e)
def _is_blocked_channel(ch):
    try: return getattr(ch, "id", None) in BLOCK_CHANNEL_IDS
    except Exception: return False
class PassiveLearningObserver(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        self.data = _safe_load(DATA_FILE)
        self.hour = time.gmtime().tm_hour
        self._ticker.start()
        log.info("[passive-learning] observer ready (slow-rate); file=%s level=%s xp=%s target=%s pts/hr",
                 DATA_FILE, self.data.get("level"), self.data.get("xp_total"), HOUR_TARGET_POINTS)
    def cog_unload(self):
        try: self._ticker.cancel()
        except Exception: pass
    def _add_points(self, pts: int):
        self.data["hour_points"] = int(self.data.get("hour_points", 0) + max(0, int(pts)))
        self.data["hour_progress_pct"] = min(100, int((self.data["hour_points"] / max(1, HOUR_TARGET_POINTS)) * 100))
    def _add_points_from_msg(self, msg: discord.Message):
        if getattr(msg.author, "bot", False): return
        if _is_blocked_channel(msg.channel): return
        content = msg.content or ""
        if len(content) < MSG_MIN_CHARS: return
        pts = POINTS_PER_MSG + (len(content) // 100) * POINTS_PER_100_CHARS
        self._add_points(pts)
    @commands.Cog.listener()
    async def on_message(self, message: discord.Message):
        self._add_points_from_msg(message)
    @commands.Cog.listener()
    async def on_message_edit(self, before: discord.Message, after: discord.Message):
        self._add_points_from_msg(after)
    @commands.Cog.listener()
    async def on_member_ban(self, guild: discord.Guild, user: discord.User):
        actor = None
        try:
            async for entry in guild.audit_logs(limit=6, action=discord.AuditLogAction.ban):
                if entry.target.id == user.id: actor = entry.user; break
        except Exception as e:
            log.debug("[passive-learning] audit log fetch fail: %s", e)
        actor_id = getattr(actor, "id", None) if actor else None
        points = BOT_BAN_POINTS if (guild.me and actor_id == guild.me.id) else MOD_ADMIN_BAN_POINTS
        self._add_points(points)
        _append_jsonl(BAN_LOG_FILE, {"ts": int(time.time()), "guild_id": guild.id, "user_banned_id": user.id, "by_id": actor_id, "points": points})
        log.info("[passive-learning] ban bonus %+d pts (user=%s by=%s)", points, user.id, actor_id)
    @tasks.loop(seconds=10)
    async def _ticker(self):
        now = time.gmtime()
        if now.tm_hour != self.hour:
            gained = int(self.data.get("hour_points", 0))
            self.data["xp_total"] = int(self.data.get("xp_total", 0) + gained)
            self.data["hour_points"] = 0
            self.data["hour_progress_pct"] = 0
            self.data["hour_start"] = int(time.time())
            self.data["level"] = _level_from_xp(self.data["xp_total"])
            self.hour = now.tm_hour
            log.info("[passive-learning] +%s XP -> total=%s level=%s", gained, self.data["xp_total"], self.data["level"])
        _safe_dump(DATA_FILE, self.data)
async def setup(bot: commands.Bot):
    await bot.add_cog(PassiveLearningObserver(bot))
>>>>>>> ef940a8 (heal)
